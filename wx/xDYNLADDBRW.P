/****************************************************************************************** 
*                                                                                         *
*  file:       XDYNLADDBRW.P                                                                   *
*  by:         Elpool i Umeå AB, 2003                                                     *
*  mailto:     anders@elpool.se                                                           *
*  http:       www.elpool.se                                                              *
*  language:   Progress 9.1D                                                              *
*  purpose:    Add some new behaviours to a browser. Sorting, searching, selection etc.   *   
*                                                                                         *
******************************************************************************************/
DEFINE VARIABLE antsc AS INTEGER NO-UNDO.
DEFINE TEMP-TABLE valsoktemp NO-UNDO
   FIELD SOKVAL AS INTEGER 
   FIELD SOKCHAR AS CHARACTER EXTENT 10
   FIELD SOKDATE AS DATE EXTENT 10
   FIELD SOKINT AS INTEGER EXTENT 10
   FIELD SOKDECI AS DECIMAL EXTENT 10
   FIELD SOKLOG AS LOGICAL EXTENT 10.

DEFINE  SHARED VARIABLE varforetypval AS INTEGER EXTENT 100 NO-UNDO.     
DEFINE  SHARED VARIABLE varforetypchar AS CHARACTER EXTENT 100 NO-UNDO.     



DEFINE SHARED VARIABLE tthandle AS HANDLE NO-UNDO.

DEFINE VARIABLE extrafalth1 AS HANDLE NO-UNDO.
DEFINE VARIABLE q AS HANDLE NO-UNDO.
DEFINE VARIABLE brwcolh AS HANDLE NO-UNDO EXTENT 15.
DEFINE VARIABLE dynladdh AS HANDLE NO-UNDO.
DEFINE VARIABLE apphandass AS HANDLE NO-UNDO.
DEFINE VARIABLE apphandklar AS HANDLE NO-UNDO.
DEFINE VARIABLE appprogok AS LOGICAL NO-UNDO.
DEFINE VARIABLE procasynch AS HANDLE NO-UNDO.
DEFINE VARIABLE fontvar AS INTEGER NO-UNDO.
DEFINE VARIABLE bgcolvar AS INTEGER NO-UNDO.
DEFINE VARIABLE labelvar AS CHARACTER NO-UNDO.
DEFINE VARIABLE aocolh AS HANDLE NO-UNDO.
DEFINE VARIABLE delnrcolh AS HANDLE NO-UNDO.
DEFINE VARIABLE brwrow AS ROWID NO-UNDO.
DEFINE VARIABLE brwsok AS CHARACTER NO-UNDO.
DEFINE VARIABLE colfinns AS LOGICAL NO-UNDO.
DEFINE VARIABLE colformat AS CHARACTER NO-UNDO.
DEFINE VARIABLE colindex AS CHARACTER NO-UNDO INITIAL ?.
DEFINE VARIABLE colindexnr AS INTEGER NO-UNDO INITIAL ?.
DEFINE VARIABLE colselnamn AS CHARACTER NO-UNDO.
DEFINE VARIABLE colsortby AS CHARACTER NO-UNDO INITIAL "".
DEFINE VARIABLE colsortcharinput AS CHARACTER NO-UNDO INITIAL "".
DEFINE VARIABLE defaultcol AS INTEGER NO-UNDO INITIAL 1.
DEFINE VARIABLE descvarcol AS LOGICAL NO-UNDO.
DEFINE VARIABLE dynbrwh AS HANDLE NO-UNDO.
DEFINE VARIABLE dynbuffh AS HANDLE NO-UNDO.
DEFINE VARIABLE dynbuffhexten AS HANDLE NO-UNDO.
DEFINE VARIABLE dyncurcolh AS HANDLE NO-UNDO.
DEFINE VARIABLE dyncurcolhlabel AS HANDLE NO-UNDO.
DEFINE VARIABLE dynfalth AS HANDLE NO-UNDO.
DEFINE VARIABLE dynlastcolh AS HANDLE NO-UNDO.
DEFINE VARIABLE dynok AS LOGICAL NO-UNDO.
DEFINE VARIABLE dynqueh AS HANDLE NO-UNDO.
DEFINE VARIABLE faltvalue AS CHARACTER NO-UNDO.
DEFINE VARIABLE frameh AS HANDLE NO-UNDO.
DEFINE VARIABLE kommandosortquery AS CHARACTER NO-UNDO.
DEFINE VARIABLE lastbrwrow AS ROWID NO-UNDO.
DEFINE VARIABLE logdate AS CHARACTER NO-UNDO.
DEFINE VARIABLE logfalse AS CHARACTER NO-UNDO.
DEFINE VARIABLE logtrue AS CHARACTER NO-UNDO.
DEFINE VARIABLE mselclick AS LOGICAL NO-UNDO INITIAL TRUE.
DEFINE VARIABLE multi AS LOGICAL NO-UNDO.
DEFINE VARIABLE multibrwsok AS CHARACTER NO-UNDO.
DEFINE VARIABLE multitid AS INTEGER NO-UNDO.
DEFINE VARIABLE retvalue AS LOGICAL NO-UNDO.
DEFINE VARIABLE saverowid AS ROWID NO-UNDO.
DEFINE VARIABLE slproc AS HANDLE NO-UNDO. 
DEFINE VARIABLE sokord AS CHARACTER NO-UNDO.
DEFINE VARIABLE tempchar AS CHARACTER NO-UNDO.
DEFINE VARIABLE tempcolh AS HANDLE NO-UNDO.
DEFINE VARIABLE tempcounter AS INTEGER NO-UNDO.
DEFINE VARIABLE tempexh AS HANDLE NO-UNDO.
DEFINE VARIABLE temph AS HANDLE NO-UNDO.
DEFINE VARIABLE tempfieldh AS HANDLE NO-UNDO.
DEFINE VARIABLE temptableh AS HANDLE NO-UNDO.
DEFINE VARIABLE titlelog AS LOGICAL NO-UNDO.
DEFINE VARIABLE trimnr AS INTEGER NO-UNDO.
DEFINE VARIABLE ttqh AS HANDLE NO-UNDO.
DEFINE VARIABLE selfh AS HANDLE NO-UNDO.
DEFINE VARIABLE otherh AS HANDLE NO-UNDO.
DEFINE VARIABLE sfalth AS HANDLE NO-UNDO.
DEFINE VARIABLE ofalth AS HANDLE NO-UNDO.
DEFINE VARIABLE ssok AS CHARACTER NO-UNDO.
DEFINE VARIABLE osok AS CHARACTER NO-UNDO.
DEFINE VARIABLE sfaltvalue AS CHARACTER NO-UNDO.
DEFINE VARIABLE ofaltvalue AS CHARACTER NO-UNDO.
DEFINE VARIABLE orgtitle AS CHARACTER NO-UNDO.
DEFINE VARIABLE multvar AS LOGICAL NO-UNDO.
DEFINE VARIABLE chfillinproc AS CHARACTER NO-UNDO INITIAL "".
DEFINE VARIABLE hfillinproc AS HANDLE NO-UNDO.
DEFINE VARIABLE colrowshift AS INTEGER NO-UNDO INITIAL 0. 
DEFINE VARIABLE colshiftlog AS LOGICAL NO-UNDO.
DEFINE VARIABLE colvalnumber AS INTEGER NO-UNDO.
DEFINE VARIABLE colproclog AS LOGICAL NO-UNDO INITIAL FALSE.
DEFINE VARIABLE disbrwcol AS INTEGER NO-UNDO.
DEFINE VARIABLE colnamevar AS CHARACTER NO-UNDO.
DEFINE VARIABLE colnamespar AS CHARACTER NO-UNDO.
DEFINE VARIABLE ascdesclog AS LOGICAL NO-UNDO.
DEFINE VARIABLE colsortchar AS CHARACTER NO-UNDO.
DEFINE VARIABLE brwantal AS INTEGER NO-UNDO.
DEFINE VARIABLE senastvarsok AS LOGICAL NO-UNDO.
DEFINE VARIABLE faltvar AS CHARACTER NO-UNDO.
DEFINE VARIABLE sokstring AS CHARACTER NO-UNDO.
DEFINE VARIABLE brwrows AS INTEGER NO-UNDO.
DEFINE VARIABLE finns AS LOGICAL NO-UNDO.
DEFINE VARIABLE begvar AS LOGICAL NO-UNDO.
DEFINE VARIABLE selrowid AS ROWID NO-UNDO.

/* Kopplar samman två fillin-fält för dubbelsökning
   ex. Förnamn- och Efternamn-fälts sökning */
DEFINE TEMP-TABLE fillintemp
   FIELD FH AS HANDLE
   FIELD SH AS HANDLE.

DEFINE TEMP-TABLE coltemp
   FIELD PROCH AS HANDLE
   FIELD CH AS HANDLE
   FIELD PROCNAME AS CHARACTER
   FIELD CNAME AS CHARACTER
   FIELD NUM AS INTEGER
   INDEX NUM AS PRIMARY NUM.

DEFINE TEMP-TABLE colcoltemp
   FIELD CH AS HANDLE
   FIELD CNAME AS CHARACTER
   FIELD NUM AS INTEGER
   INDEX NUM AS PRIMARY NUM.

   
DEFINE TEMP-TABLE multiseltemp
   FIELD NUMSEL AS INTEGER
   FIELD SELROW AS ROWID
   INDEX NUM AS PRIMARY NUMSEL.

/* Håller ordning på menyerna i varje enskild browser. */
DEFINE TEMP-TABLE menutemp
   FIELD MENUH AS HANDLE
   FIELD MENUITEMH AS HANDLE
   FIELD BRWH AS HANDLE.
   

/************************* RUN DYNBRW.P PERSISTENT SET ... ********************************
*  Kräver en handle till en browser vid första anrop, ex:                                 *
*     RUN XDYNLADDBRW.P PERSISTENT SET 'brwprochandle' (INPUT {&BROWSE-NAME}:HANDLE).      *
*  Använd sedan 'brwprochandle' för att anropa interna procedurer i denna fil, ex:        *
*     RUN openbdynspec_UI in 'brwprochandle'.                                             *
******************************************************************************************/

/********************************** INPUT Variables **************************************/
DEFINE INPUT PARAMETER brwh AS HANDLE.
dynbrwh = brwh.
RUN brwsetup_UI.
dynqueh = dynbrwh:QUERY.
dynbuffh = dynqueh:GET-BUFFER-HANDLE.
dyncurcolh = dynbrwh:GET-BROWSE-COLUMN(defaultcol).
dyncurcolhlabel = dynbrwh:GET-BROWSE-COLUMN(defaultcol).
multvar = dynbrwh:MULTIPLE.
orgtitle = dynbrwh:TITLE.
ASSIGN
multibrwsok = ""
brwsok = ""
finns = FALSE.
/* Denna del används för randiga browsrar */
colshiftlog = FALSE.       /* TRUE = Randig browser */


/********************************** Triggers *********************************************/

/* Följande rader kopplar ihop 'händelser', för browsern, med procedurer. 
*  Detta för att alla browsrar som använder sig av XDYNLADDBRW.P har gemensamma 
*  funktioner för olika 'händelser' som t.ex. ANY-PRINTABLE kopplas till proceduren
*  'hittadyn_UI' som har till uppgift att söka igenom innehållet i browsern utifrån
*  den tangent man har tryckt och sedan markera den rad som först stämmer överens. 
*/

/* ON ANY-PRINTABLE OF dynbrwh PERSISTENT RUN hittadyn_UI IN THIS-PROCEDURE.    */
ON START-SEARCH OF dynbrwh PERSISTENT RUN sortcolstart_UI IN THIS-PROCEDURE.
/* ON START-SEARCH OF dynbrwh PERSISTENT RUN startsearchproc IN THIS-PROCEDURE. */
ON CTRL-A OF dynbrwh PERSISTENT RUN ctrlaproc IN THIS-PROCEDURE.
ON CTRL-C OF dynbrwh PERSISTENT RUN ctrlcproc IN THIS-PROCEDURE.
ON CTRL-Z OF dynbrwh PERSISTENT RUN multiselect_UI IN THIS-PROCEDURE.
ON ROW-DISPLAY OF dynbrwh PERSISTENT RUN rowdisplayproc IN THIS-PROCEDURE.
ON MOUSE-SELECT-CLICK OF dynbrwh PERSISTENT RUN mouseselclick IN THIS-PROCEDURE.
RETURN.

/* Genom att skapa en procedure som körs internt, kan man köra denna fil både 
   persistent och vanligt. */

/******************************* Trigger Procedures *************************************/


PROCEDURE nyladdabrw_UI :
   DEFINE INPUT PARAMETER TABLE FOR valsoktemp.  
   FIND FIRST valsoktemp NO-LOCK NO-ERROR.
   IF AVAILABLE valsoktemp THEN DO:
      ASSIGN
      colsortcharinput = valsoktemp.SOKCHAR[2]
      colsortchar = valsoktemp.SOKCHAR[2].
      RUN getcolname_UI (OUTPUT colnamevar,OUTPUT ascdesclog).
      IF colnamevar NE ? OR colnamevar NE "" THEN DO:
            RUN xDYNLADDBRWAPP.P PERSISTENT SET dynladdh
            (INPUT TABLE-HANDLE tthandle).
         
         RUN laddatemp_UI IN dynladdh (OUTPUT TABLE-HANDLE tthandle,INPUT TABLE valsoktemp,
                                       INPUT colnamevar,INPUT descvarcol).
         RUN openbdyn_UI (INPUT colsortcharinput).
         dynqueh:GET-FIRST(NO-LOCK).
         lastbrwrow = dynbuffh:ROWID.
         RUN lastselectdyn_UI.                                
         ASSIGN
         dynbrwh:MAX-DATA-GUESS = brwantal
         colsortchar = colsortcharinput  
         dynbrwh:TITLE = orgtitle
         colnamespar = colnamevar
         senastvarsok = FALSE. 
      END.
      RETURN.
  END.
END PROCEDURE.


PROCEDURE hmtnasta_UI :
   
   antsc = antsc + 1.
   dynbrwh:TITLE = string(antsc) + " if = 13 look AT the sort".
   IF antsc = 12 THEN DO:
      MESSAGE "kommandosortquery =" kommandosortquery SKIP
        "colindex =" colindex SKIP
        "colsortby =" colsortby SKIP
         VIEW-AS ALERT-BOX.

   END.
   IF antsc = 13 THEN DO:
      MESSAGE "13" "kommandosortquery =" kommandosortquery SKIP
        "colindex =" colindex SKIP
        "colsortby =" colsortby SKIP
         VIEW-AS ALERT-BOX.
   END.
   RUN getcolname_UI (OUTPUT colnamevar,OUTPUT ascdesclog).
   IF colnamevar NE ? OR colnamevar NE "" THEN DO:
      IF colnamevar NE colnamespar THEN DO:
         dynbrwh:TITLE = orgtitle + "   Vänta, omsortering pågår... ".
         colnamespar = colnamevar.
      END. 
      RUN getnumresult_UI (OUTPUT brwantal).
      dynqueh:GET-LAST(NO-LOCK).
      brwrow = dynbuffh:ROWID.
      lastbrwrow = brwrow.
      dynqueh:REPOSITION-TO-ROWID(lastbrwrow) NO-ERROR.
      dynbrwh:SELECT-FOCUSED-ROW() NO-ERROR.
      RUN fetchselrowid_UI. 
      RUN selmulti_UI.
      RUN hmtnasta_UI IN dynladdh (OUTPUT TABLE-HANDLE tthandle APPEND,
                                 INPUT colnamevar,INPUT descvarcol,INPUT brwantal).
      RUN refreshbrw_UI.
      RUN multiselect_UI.  
      RUN getnumresult_UI (OUTPUT brwantal).
      dynbrwh:MAX-DATA-GUESS = brwantal.
      dynqueh:REPOSITION-TO-ROWID(lastbrwrow) NO-ERROR.
      dynbrwh:DESELECT-FOCUSED-ROW() NO-ERROR.
      
      ASSIGN
      colsortchar = colsortcharinput
      colnamespar = colnamevar. 
   END.
   
   RETURN.
END PROCEDURE.

PROCEDURE hmtforegaende_UI :
   RUN getcolname_UI (OUTPUT colnamevar,OUTPUT ascdesclog).
   IF colnamevar NE ? OR colnamevar NE "" THEN DO:
      IF colnamevar NE colnamespar THEN DO:
         dynbrwh:TITLE = orgtitle + "   Vänta, omsortering pågår... ".
         colnamespar = colnamevar.
      END.
      RUN getnumresult_UI (OUTPUT brwantal).
      dynqueh:GET-FIRST(NO-LOCK).
      brwrow = dynbuffh:ROWID.
      lastbrwrow = brwrow.
      dynqueh:REPOSITION-TO-ROWID(lastbrwrow) NO-ERROR.
      dynbrwh:SELECT-FOCUSED-ROW() NO-ERROR.
      RUN fetchselrowid_UI. 
      RUN selmulti_UI.
      RUN hmtforegaende_UI IN dynladdh (OUTPUT TABLE-HANDLE tthandle APPEND,
                                    INPUT colnamevar,INPUT descvarcol,INPUT brwantal).
      RUN refreshbrw_UI.   
      RUN multiselect_UI.  
      RUN getnumresult_UI (OUTPUT brwantal).
      dynbrwh:MAX-DATA-GUESS = brwantal.
      dynqueh:REPOSITION-TO-ROWID(lastbrwrow) NO-ERROR.
      dynbrwh:DESELECT-FOCUSED-ROW() NO-ERROR.
      IF senastvarsok THEN dynbrwh:TITLE = orgtitle + "   Urvalresultat ".
      ELSE dynbrwh:TITLE = orgtitle.
      ASSIGN
      colsortchar = colsortcharinput
      colnamespar = colnamevar.  
   END.
   RETURN.
END PROCEDURE.

PROCEDURE hmtsista_UI :
   RUN getcolname_UI (OUTPUT colnamevar,OUTPUT ascdesclog).
   IF senastvarsok THEN DO:
      dynqueh:GET-LAST(NO-LOCK).
      lastbrwrow = dynbuffh:ROWID.
      RUN lastselectdyn_UI.      
   END.
   ELSE DO:
      IF colnamevar NE ? OR colnamevar NE "" THEN DO:
         IF colnamevar NE colnamespar THEN DO:
            dynbrwh:TITLE = orgtitle + "   Vänta, omsortering pågår... ".
            colnamespar = colnamevar.
         END.
         RUN hmtsista_UI IN dynladdh (OUTPUT TABLE-HANDLE tthandle,
                                      INPUT colnamevar,INPUT descvarcol).
         RUN refreshbrw_UI.  
         RUN getnumresult_UI (OUTPUT brwantal).
         IF senastvarsok THEN dynbrwh:TITLE = orgtitle + "   Urvalresultat ".
         ELSE dynbrwh:TITLE = orgtitle.
         ASSIGN
         dynbrwh:MAX-DATA-GUESS = brwantal
         colsortchar = colsortcharinput
         colnamespar = colnamevar.      
      END.
   END.
   RETURN.
END PROCEDURE.

PROCEDURE hmtforsta_UI :
   RUN getcolname_UI (OUTPUT colnamevar,OUTPUT ascdesclog).
   IF senastvarsok THEN DO:
      dynqueh:GET-FIRST(NO-LOCK).
      lastbrwrow = dynbuffh:ROWID.
      RUN lastselectdyn_UI.      
   END.
   ELSE DO:
      IF colnamevar NE ? OR colnamevar NE "" THEN DO:
         IF colnamevar NE colnamespar THEN DO:
            dynbrwh:TITLE = orgtitle + "   Vänta, omsortering pågår... ".
            colnamespar = colnamevar.
         END.
         RUN hmtforsta_UI IN dynladdh (OUTPUT TABLE-HANDLE tthandle,
                                       INPUT colnamevar,INPUT descvarcol).
         RUN refreshbrw_UI. 
         RUN getnumresult_UI (OUTPUT brwantal).
         IF senastvarsok THEN dynbrwh:TITLE = orgtitle + "   Urvalresultat ".
         ELSE dynbrwh:TITLE = orgtitle.
         ASSIGN
         dynbrwh:MAX-DATA-GUESS = brwantal
         colsortchar = colsortcharinput
         colnamespar = colnamevar.          
      END.
   END.
   RETURN.
END PROCEDURE.
PROCEDURE rowdisplayproc :
   IF VALID-HANDLE(delnrcolh) THEN DO:
      delnrcolh:FORMAT = varforetypchar[1].
   END.
   IF VALID-HANDLE(aocolh) THEN DO:
      IF varforetypval[8] = 8 THEN aocolh:FORMAT = "X(8)".
      ELSE IF varforetypval[8] = 7 THEN aocolh:FORMAT = "X(7)".
   END.

   IF VALID-HANDLE(brwcolh[1]) THEN DO:
      brwcolh[1]:FORMAT = "X(256)".      
   END.
   IF VALID-HANDLE(brwcolh[2]) THEN DO:
      brwcolh[2]:FORMAT = "X(256)".      
   END.
   IF VALID-HANDLE(brwcolh[3]) THEN DO:
      brwcolh[3]:FORMAT = "X(256)".      
   END.

   IF colshiftlog = TRUE THEN DO:
      IF (dynqueh:CURRENT-RESULT-ROW MODULO 2) = 0 THEN DO:
         FOR EACH coltemp NO-LOCK:
            coltemp.CH:BGCOLOR = colvalnumber.
         END.
      END.      
   END.
   IF colproclog = TRUE THEN DO:
      FOR EACH coltemp WHERE coltemp.PROCH NE ? NO-LOCK:
         RUN VALUE(coltemp.PROCNAME) IN coltemp.PROCH 
            (INPUT coltemp.CNAME, INPUT coltemp.CH, INPUT dynbuffh:BUFFER-FIELD(coltemp.CNAME)).
      END.
   END.
END PROCEDURE.
PROCEDURE mouseselclick :
   IF mselclick = TRUE THEN DO:
      
   END.
END PROCEDURE.
PROCEDURE mouseselclick_UI :
   DEFINE INPUT PARAMETER mclick AS LOGICAL NO-UNDO.
   mselclick = mclick.
END PROCEDURE.

PROCEDURE anyhmt_UI :
   DEFINE INPUT PARAMETER brwsok2 AS CHARACTER NO-UNDO.
   DEFINE VARIABLE timevar AS INTEGER NO-UNDO.
   multibrwsok = brwsok2.
   
   IF SUBSTRING(brwsok2,2,1) = "" THEN DO:
      IF senastvarsok = FALSE THEN DO:
          RUN anyprinthmt_UI.                 
      END.
      ELSE RUN anyprinthmt_UI.
   END.   
   
   brwsok2 = "".
   RETURN.
END PROCEDURE.

PROCEDURE anyprinthmt_UI :
   RUN getcolname_UI (OUTPUT colnamevar,OUTPUT ascdesclog).
   IF senastvarsok = TRUE THEN DO:
      extrafalth1 = dynbuffh:BUFFER-FIELD(dyncurcolh:NAME).
      dynqueh:GET-FIRST(NO-LOCK).
      DO WHILE dynqueh:QUERY-OFF-END = FALSE:
         IF extrafalth1:BUFFER-VALUE BEGINS STRING(multibrwsok) THEN DO:
            lastbrwrow = dynbuffh:ROWID.
            RUN lastselectdyn_UI.
            LEAVE.
         END.
         dynqueh:GET-NEXT(NO-LOCK).
      END.      
   END.
   ELSE DO:
      IF colnamevar NE ? OR colnamevar NE "" THEN DO:
         IF colnamevar NE colnamespar THEN DO:
            dynbrwh:TITLE = orgtitle + "   Vänta, omsortering pågår... ".
            colnamespar = colnamevar.
         END.
         dynbrwh:TITLE = orgtitle + "   Vänta, sökning pågår... ".
         RUN anyhmt_UI IN dynladdh (OUTPUT TABLE-HANDLE tthandle,
                              INPUT colnamevar,INPUT descvarcol,
                              INPUT multibrwsok).
         RUN refreshbrw_UI.  
         dynqueh:GET-FIRST(NO-LOCK).
         RUN fetchselrowid_UI.
         RUN getnumresult_UI (OUTPUT brwantal).
         IF senastvarsok THEN dynbrwh:TITLE = orgtitle + "   Urvalresultat ".
         ELSE dynbrwh:TITLE = orgtitle.
         ASSIGN
         dynbrwh:MAX-DATA-GUESS = brwantal
         colsortchar = colsortcharinput
         colnamespar = colnamevar.                        
      END.
   END.
   multibrwsok = "".
   IF appprogok = TRUE THEN DO:                                          
      RUN ASSYNAPP.P (INPUT 2,OUTPUT appprogok,INPUT-OUTPUT Guru.Konstanter:apphandass). 
      IF VALID-HANDLE(Guru.Konstanter:apphandass) THEN DELETE PROCEDURE Guru.Konstanter:apphandass NO-ERROR.
      IF VALID-HANDLE(Guru.Konstanter:apphandklar) THEN DELETE PROCEDURE Guru.Konstanter:apphandklar NO-ERROR.                                              
      IF VALID-HANDLE(procasynch) THEN DELETE PROCEDURE procasynch NO-ERROR.
   END.   
   RETURN.  
END PROCEDURE.

PROCEDURE sokhmt_UI :
   DEFINE INPUT PARAMETER TABLE FOR valsoktemp.
   DEFINE OUTPUT PARAMETER felmedd AS CHARACTER NO-UNDO.
   ASSIGN
   senastvarsok = TRUE      
   felmedd = "".
   FIND FIRST valsoktemp NO-LOCK NO-ERROR.
   IF AVAILABLE valsoktemp THEN DO:
      ASSIGN
      faltvar = valsoktemp.SOKCHAR[1]  
      sokstring = valsoktemp.SOKCHAR[2].
      RUN getcolname_UI (OUTPUT colnamevar,OUTPUT ascdesclog).
      IF colnamevar NE ? OR colnamevar NE "" THEN DO:
         IF colnamevar NE colnamespar THEN DO:
            dynbrwh:TITLE = orgtitle + "   Vänta, omsortering pågår... ".
            colnamespar = colnamevar.
         END.
         dynbrwh:TITLE = orgtitle + "   Vänta, sökning pågår... ".
         /*dynbuffh:EMPTY-TEMP-TABLE  NO-ERROR. */
         RUN sokhmt_UI IN dynladdh (OUTPUT TABLE-HANDLE tthandle,INPUT TABLE valsoktemp,
                                    INPUT descvarcol,OUTPUT felmedd).
         IF INDEX(sokstring,"*",1) = 0 THEN DO:
            begvar = TRUE.            
         END.
         IF SUBSTRING(sokstring,1,1) = "*" THEN DO:
            begvar = FALSE.            
         END.  
         RUN refreshbrw_UI.  
         dynqueh:GET-FIRST(NO-LOCK).
         DO WHILE dynqueh:QUERY-OFF-END = FALSE:
            extrafalth1 = dynbuffh:BUFFER-FIELD(faltvar).
            IF begvar = FALSE THEN DO:
               IF extrafalth1:BUFFER-VALUE MATCHES sokstring THEN DO:
                  lastbrwrow = dynbuffh:ROWID.
                  finns = TRUE.
                  LEAVE.
               END.
            END.
            ELSE DO:
               IF extrafalth1:BUFFER-VALUE BEGINS sokstring THEN DO:
                  lastbrwrow = dynbuffh:ROWID.
                  finns = TRUE.
                  LEAVE.
               END.
            END.
            dynqueh:GET-NEXT(NO-LOCK).
         END.  
         IF finns = FALSE THEN DO:
            dynqueh:GET-FIRST(NO-LOCK).
            lastbrwrow = dynbuffh:ROWID.
         END.
         RUN lastselectdyn_UI.
         RUN getnumresult_UI (OUTPUT brwantal).
         ASSIGN
         dynbrwh:MAX-DATA-GUESS = brwantal
         dynbrwh:TITLE = orgtitle + "   Urvalresultat "
         colsortchar = colsortcharinput
         colnamespar = colnamevar
         finns = FALSE.
      END.
   END.
   RETURN.
END PROCEDURE.

PROCEDURE sortcolstart_UI :
   dyncurcolh = dynbrwh:CURRENT-COLUMN.
   IF VALID-HANDLE(dyncurcolh) = FALSE THEN DO:
      dyncurcolh = dynbrwh:GET-BROWSE-COLUMN(defaultcol).
   END.
   RUN getcolname_UI (OUTPUT colnamevar,OUTPUT ascdesclog).
   IF senastvarsok THEN DO:
      RUN colsortdynbrw_UI (INPUT colsortcharinput).
      colnamespar = colnamevar.  
   END.
   ELSE DO:
      RUN colsortdynbrw_UI (INPUT colsortcharinput).
      IF colnamevar NE ? OR colnamevar NE "" THEN DO:      
         IF colnamevar NE colnamespar THEN DO:
            dynbrwh:TITLE = orgtitle + "   Vänta, omsortering pågår... ".
            dynbuffh = dynqueh:GET-BUFFER-HANDLE.
            RUN laddasort_UI IN dynladdh (OUTPUT TABLE-HANDLE tthandle,
                                          INPUT colnamevar,INPUT descvarcol).
                                          
/*             RUN laddatemp_UI IN dynladdh (OUTPUT TABLE-HANDLE tthandle,INPUT TABLE valsoktemp, */
/*                                        INPUT colnamevar,INPUT descvarcol).                */
            RUN refreshbrw_UI.
            dynqueh:GET-FIRST(NO-LOCK).
            brwrow = dynbuffh:ROWID.
            lastbrwrow = brwrow.
            RUN fetchselrowid_UI.
            RUN lastselectdyn_UI.
            RUN getnumresult_UI (OUTPUT brwantal).
            dynbrwh:MAX-DATA-GUESS = brwantal.
            ASSIGN
            dynbrwh:TITLE = orgtitle
            colsortchar = colsortcharinput
            colnamespar = colnamevar.
         END.
         ELSE DO:
            IF descvarcol THEN DO:
               dynqueh:GET-LAST(NO-LOCK).
            END.
            ELSE DO:
               dynqueh:GET-FIRST(NO-LOCK).
            END.
            RUN fetchselrowid_UI. 
            RUN repodyn_UI (INPUT lastbrwrow).
            RUN getnumresult_UI (OUTPUT brwantal).
            dynbrwh:MAX-DATA-GUESS = brwantal.
            IF senastvarsok THEN dynbrwh:TITLE = orgtitle + "   Urvalresultat ".
            ELSE dynbrwh:TITLE = orgtitle.
            ASSIGN
            colsortchar = colsortcharinput
            colnamespar = colnamevar.             
         END.
      END.
   END.
   RETURN.
END PROCEDURE.

/*------------------------------------------------------------------------------
   Namn:       startsearchproc                  
   Syfte:      Lagra den senast markerade posten, sortera om browsern och 
               markera sedan den senast valda posten.
   In-data:    -
   Ut-data:    -
   Kommentar:  Event procedure, anropas vid START-SEARCH händelse.
------------------------------------------------------------------------------*/
PROCEDURE startsearchproc :
   RUN fetchselrowid_UI.
   RUN selmulti_UI.
   RUN colsortdynbrw_UI (INPUT colsortcharinput).    
   RUN multiselect_UI.
END PROCEDURE.

/*------------------------------------------------------------------------------
   Namn:       ctrlaproc
   Syfte:      Markerar alla poster i browsern.
   In-data:    -
   Ut-data:    -
   Kommentar:  Event procedure, anropas vid CTRL-A händelse.
------------------------------------------------------------------------------*/
PROCEDURE ctrlaproc :
   IF multvar = TRUE THEN dynbrwh:SELECT-ALL().   
END PROCEDURE.

PROCEDURE enablebrw_UI.
   DEFINE INPUT PARAMETER elog AS LOGICAL NO-UNDO.
   brwh:SENSITIVE = elog.
   IF elog = FALSE THEN brwh:BGCOLOR = disbrwcol.
   ELSE brwh:BGCOLOR = ?.   
END PROCEDURE.


PROCEDURE openbdyn_UI :
   DEFINE INPUT PARAMETER tabvar AS CHARACTER NO-UNDO.
   IF dyncurcolh:NAME = ? THEN RETURN.
   colrowshift = 0.
   dynbuffh = dynqueh:GET-BUFFER-HANDLE(1).
   IF descvarcol = FALSE THEN DO:
      IF colindex = ? THEN DO:
         kommandosortquery = "FOR EACH " + dynbuffh:TABLE + tabvar + " NO-LOCK BY " + dyncurcolh:NAME + colsortby + ".".
      END.
      ELSE DO:
         kommandosortquery = "FOR EACH " + dynbuffh:TABLE + tabvar + " NO-LOCK BY " + colindex + colsortby + ".".
      END.      
   END.
   ELSE DO:
      IF colindex = ? THEN DO:
         kommandosortquery = "FOR EACH " + dynbuffh:TABLE + tabvar + " NO-LOCK BY " + dyncurcolh:NAME + " DESCENDING " + colsortby + ".".
      END.
      ELSE DO:
         /*kommandosortquery = "FOR EACH " + dynbuffh:TABLE + tabvar + " NO-LOCK BY " + colindex + " DESCENDING " + colsortby + ".".  */
         kommandosortquery = "FOR EACH " + dynbuffh:TABLE + tabvar + " NO-LOCK BY " + colindex + colsortby + " DESCENDING " + ".".         
      END.      
   END.     
   dynok = dynqueh:QUERY-PREPARE(kommandosortquery).
   IF dynok = TRUE THEN DO: 
      dynok = dynqueh:QUERY-OPEN() NO-ERROR.
      IF dynok = FALSE THEN DO:
         IF descvarcol = FALSE THEN DO:
            IF colindex = ? THEN DO:
               kommandosortquery = "FOR EACH " + dynbuffh:TABLE + tabvar + " NO-LOCK BY SUBSTRING( " + dyncurcolh:NAME + ", 1, 127)" + colsortby + ".".
            END.
            ELSE DO:
               kommandosortquery = "FOR EACH " + dynbuffh:TABLE + tabvar + " NO-LOCK BY " + colindex + colsortby + ".".
            END.      
         END.
         ELSE DO:
            IF colindex = ? THEN DO:
               kommandosortquery = "FOR EACH " + dynbuffh:TABLE + tabvar + " NO-LOCK BY SUBSTRING( " + dyncurcolh:NAME + ", 1, 127) DESCENDING " + colsortby + ".".
            END.
            ELSE DO:
               kommandosortquery = "FOR EACH " + dynbuffh:TABLE + tabvar + " NO-LOCK BY " + colindex + " DESCENDING " + colsortby + ".".
            END.      
         END.
         dynok = dynqueh:QUERY-PREPARE(kommandosortquery).
         dynok = dynqueh:QUERY-OPEN().
      END.
      IF titlelog = TRUE THEN DO:
         RUN title_UI.
      END.
      ELSE RUN maxdata_UI.
   END.
   ELSE DO:
      MESSAGE "Kunde inte ladda Browser-Query!" VIEW-AS ALERT-BOX. 
      RETURN.
   END.   
END PROCEDURE.


/*------------------------------------------------------------------------------
   Namn:       colsortdynbrw_UI                  
   Syfte:      Öppnar en query sorterad utifrån vald kolumn. 
               Om samma kolumn väljs två gånger sorteras posterna i omvänd ordning. 
   In-data:    tabvar [CHAR] - Kommandosträng för öppnadet av en query.
               Lämnas tom ifall man vill erhålla allt innehåll.
               ex. "WHERE temptable.FIELD = vtemptable.FIELD", "".
   Ut-data:    -
   Kommentar:  Kräver att initdynbrw_UI har körts!
------------------------------------------------------------------------------*/
PROCEDURE colsortdynbrw_UI :
   DEFINE INPUT PARAMETER tabvar AS CHARACTER NO-UNDO.

   dynbuffh = dynqueh:GET-BUFFER-HANDLE(1).
   dyncurcolh = dynbrwh:CURRENT-COLUMN.
   IF VALID-HANDLE(dyncurcolh) = FALSE THEN DO:
      dyncurcolh = dynbrwh:GET-BROWSE-COLUMN(defaultcol).
   END.
   IF dyncurcolh NE ? THEN DO:
      IF dyncurcolh:NAME NE ? THEN DO:
         IF dyncurcolh:PRIVATE-DATA NE ? THEN DO:
            IF ENTRY(1,dyncurcolh:PRIVATE-DATA,"$") NE "?" THEN DO: 
               tabvar = ENTRY(1,dyncurcolh:PRIVATE-DATA,"$").
            END.
            IF ENTRY(2,dyncurcolh:PRIVATE-DATA,"$") NE "?" THEN DO: 
               colsortby = " BY " + ENTRY(2,dyncurcolh:PRIVATE-DATA,"$").
            END.      
            ELSE colsortby = "".
              
         END.
         
         ELSE DO:
            
            dynbuffhexten = dyncurcolh:BUFFER-FIELD().
                                
            IF dynbuffhexten:EXTENT = 0 THEN DO:
               IF colindex NE ? THEN colsortby = " BY " + dyncurcolh:NAME.
            END.
            ELSE DO:
              /* MESSAGE dynbuffhexten:EXTENT dynbuffhexten:NAME dyncurcolh:LABEL VIEW-AS ALERT-BOX.*/
            END.
            
         END.
         
      END.
      ELSE DO: 
         dyncurcolh = dynlastcolh.
         RETURN.
      END.
      /*Om samma kolumn har blivit tryckt på sortera i annan ordning.*/

      IF dynlastcolh = dyncurcolh THEN DO:
         IF descvarcol = TRUE THEN descvarcol = FALSE.
         ELSE descvarcol = TRUE.           
      END.
      ELSE DO:
         IF dynlastcolh NE ? THEN DO:
            ASSIGN
            dynlastcolh:LABEL-BGCOLOR = bgcolvar
            dynlastcolh:LABEL-FONT   =   fontvar
            dynlastcolh:LABEL   = labelvar. 
         END.
         ASSIGN
         bgcolvar = dyncurcolh:LABEL-BGCOLOR
         fontvar  = dyncurcolh:LABEL-FONT
         labelvar = dyncurcolh:LABEL
         descvarcol = FALSE.
         ASSIGN     
         dyncurcolh:LABEL-FONT = 4
         dyncurcolh:LABEL-BGCOLOR = 15. 
         
      END.
      /*Spara undan senast intryckta kolumn för en specifik browser(brwvar[ex. värdet 1])*/
      IF descvarcol = FALSE THEN dyncurcolh:LABEL   = labelvar + " ^".
      ELSE dyncurcolh:LABEL   = labelvar + " v".
      dynlastcolh = dyncurcolh.               
   END.
   ELSE dyncurcolh = dynlastcolh.
   /* Ifall det inte finns någon kolumn markerad, ex. anrop till openbdyn_UI från
      'btn_hamt' triggern.*/
   RUN openbdyn_UI (INPUT tabvar).
END PROCEDURE.

/*------------------------------------------------------------------------------
   Namn:       comparedyn_UI                  
   Syfte:      
   In-data:    val [INT] - (1,2) används för att jämföra innehållet i ett fält
                  1 - Jämför med BEGINS
                  2 - Jämför med MATCHES
   Ut-data:    retval [BOOL] - Returnerar ett värde på hur jämförandet gick.
                  TRUE - Har hittat ett sökt värde och markerat denna rad.
                  FALSE - Hittade inget värde, ingen rad markerad i browsern.
   Kommentar:  Måste känna till en hel del variabler, anropas från sokurvaldyn_UI 
               och hittadyn_UI. Bör ej anropas separat från huvudprogram.
------------------------------------------------------------------------------*/
PROCEDURE comparedyn_UI :
   DEFINE INPUT PARAMETER val AS INTEGER.
   DEFINE OUTPUT PARAMETER retval AS LOGICAL.
   retval = FALSE.
   /*Hämtar en 'fält-handle' från den aktiva buffern*/
/*    dynfalth = dynbuffh:BUFFER-FIELD(dyncurcolh:NAME). */
   /* "colh" är en handle till en kolumn, blir satt i hittadyn_UI.*/
   IF dynfalth:DATA-TYPE = "LOGICAL" THEN DO:
      /*"colformat" kan exempelvis få värdet "Ja/Nej" */
      colformat = dynfalth:FORMAT.
      /* Plockar ut 'Ja' och 'Nej' för att kunna jämför kanpptryckningar mot
         detta värde.*/
      logtrue = ENTRY (1,  colformat, "/").
      logfalse = ENTRY (2,  colformat, "/").
      IF dynfalth:BUFFER-VALUE = TRUE THEN DO:
         faltvalue = logtrue.
      END.
      ELSE DO:
         faltvalue = logfalse.
      END.
   END.
   ELSE IF dynfalth:DATA-TYPE = "DATE" AND val = 1 THEN DO:
      trimnr = 1.
      faltvalue = "".
      logdate = string(dynfalth:BUFFER-VALUE).
      DO WHILE trimnr NE 0:
         trimnr = INDEX(logdate, "/").
         faltvalue = faltvalue + SUBSTRING(logdate, 1, trimnr - 1).
         logdate = TRIM(SUBSTRING(logdate, trimnr + 1)).
      END.
   END.                            
   ELSE IF dynfalth:DATA-TYPE = "INTEGER"  THEN DO:     
      sokord = REPLACE(sokord,",","").      
      faltvalue = string(dynfalth:BUFFER-VALUE).
   END.
   ELSE DO:
      faltvalue = string(dynfalth:BUFFER-VALUE).
   END.
   IF val = 1 THEN DO:
      IF faltvalue BEGINS multibrwsok THEN DO:
         brwrow = dynbuffh:ROWID.
         lastbrwrow = brwrow.
         RUN selectdyn_UI (INPUT brwrow).
         retval = TRUE.
         RETURN.
      END.
   END.
   ELSE IF val = 2 THEN DO:
      IF faltvalue MATCHES sokord THEN DO:
         brwrow = dynbuffh:ROWID.
         lastbrwrow = brwrow.
         RUN repodyn_UI (INPUT brwrow).
         dynbrwh:SELECT-FOCUSED-ROW() NO-ERROR. 
         retval = TRUE.
         RETURN.
      END.
   END.
END PROCEDURE.

PROCEDURE repodyn_UI :
   DEFINE INPUT PARAMETER brwrow AS ROWID NO-UNDO.
   dynbrwh:REFRESHABLE = FALSE.
   dynbrwh:SET-REPOSITIONED-ROW(35,"ALWAYS").
   dynqueh:REPOSITION-TO-ROWID(brwrow) NO-ERROR.
   dynbrwh:REFRESHABLE = TRUE. 
   APPLY "VALUE-CHANGED" TO dynbrwh.
   
   
END PROCEDURE.


/*------------------------------------------------------------------------------
   Namn:       selectbyrowid_UI                  
   Syfte:      Markerar den rad med passande ROWID 
   In-data:    browrow [ROWID] - ROWID för raden som ska markeras.
   Ut-data:    -
   Kommentar:  Måste känna till "dynbrwh" för att proceduren ska fungera.
------------------------------------------------------------------------------*/
PROCEDURE selectbyrowid_UI :
   DEFINE INPUT PARAMETER selid AS ROWID NO-UNDO.
   lastbrwrow = selid.
   RUN lastselectdyn_UI.
END PROCEDURE.

/*------------------------------------------------------------------------------
   Namn:       selectdyn_UI                  
   Syfte:      Markerar och avmarkerar rader i browsern. Avmarkerar rader som har
               markerats vid multiselect-knapptryckning.
   In-data:    browrow [ROWID] - ROWID för raden som ska markeras.
   Ut-data:    -
   Kommentar:  Måste känna till "dynbrwh" för att proceduren ska fungera.
------------------------------------------------------------------------------*/
PROCEDURE selectdyn_UI :
   DEFINE INPUT PARAMETER browrow AS ROWID NO-UNDO.
   DEFINE VARIABLE rowsel AS LOGICAL NO-UNDO.
   RUN repodyn_UI (INPUT browrow).
   rowsel = dynbrwh:FOCUSED-ROW-SELECTED.
   IF rowsel = FALSE AND multi = FALSE THEN DO: 
      saverowid = browrow.
      dynbrwh:SELECT-FOCUSED-ROW() NO-ERROR.
   END.
   ELSE IF rowsel = TRUE AND multi = FALSE THEN DO:
      saverowid = ?.  
      dynbrwh:SELECT-FOCUSED-ROW() NO-ERROR.
   END.
   ELSE IF multi = TRUE THEN DO:
      IF saverowid NE ? THEN DO:
         RUN repodyn_UI (INPUT saverowid).
         dynbrwh:DESELECT-FOCUSED-ROW() NO-ERROR.
      END.
      RUN repodyn_UI (INPUT browrow).
      dynbrwh:SELECT-FOCUSED-ROW() NO-ERROR.
      IF rowsel = FALSE THEN DO:
         saverowid = browrow.
      END.
   END.
END PROCEDURE.


/*------------------------------------------------------------------------------
   Namn:       lastselectdyn_UI                
   Syfte:      -  
   In-data:    -
   Ut-data:    -
   Kommentar:  -
------------------------------------------------------------------------------*/
PROCEDURE lastselectdyn_UI :
   
   IF lastbrwrow NE ? THEN DO:
      RUN repodyn_UI (INPUT lastbrwrow).
      dynbrwh:SELECT-FOCUSED-ROW() NO-ERROR.      
/*       dynqueh:GET-CURRENT(NO-LOCK) NO-ERROR. */
   END.
END PROCEDURE.

/*------------------------------------------------------------------------------
   Namn:       setlastrowid_UI                
   Syfte:      -  
   In-data:    -
   Ut-data:    -
   Kommentar:  -
------------------------------------------------------------------------------*/
PROCEDURE setlastrowid_UI :
   DEFINE INPUT PARAMETER inrow AS ROWID.
   lastbrwrow = inrow.
END PROCEDURE.



/*------------------------------------------------------------------------------
   Namn:       setcolsortvar_UI                
   Syfte:      -  
   In-data:    -
   Ut-data:    -
   Kommentar:  -
------------------------------------------------------------------------------*/
PROCEDURE setcolsortvar_UI :
   DEFINE INPUT PARAMETER sortvar AS CHARACTER NO-UNDO.
   IF INDEX(sortvar,"WHERE") = 0 THEN colsortcharinput = " WHERE " + sortvar.
   ELSE colsortcharinput = sortvar.   
END PROCEDURE.

/*------------------------------------------------------------------------------
   Namn:       settriggerproc_UI               
   Syfte:      -  
   In-data:    -
   Ut-data:    -
   Kommentar:  -
------------------------------------------------------------------------------*/
PROCEDURE settriggerproc_UI :
   DEFINE INPUT PARAMETER val AS INTEGER NO-UNDO.
   DEFINE INPUT PARAMETER procname AS CHARACTER NO-UNDO.
   IF val = 1 THEN DO:
      ON START-SEARCH OF dynbrwh PERSISTENT RUN VALUE(procname) IN SOURCE-PROCEDURE.
   END.
   ELSE IF val = 2 THEN DO:
      ON ANY-PRINTABLE OF dynbrwh PERSISTENT RUN VALUE(procname) IN SOURCE-PROCEDURE.
   END.   
   ELSE IF val = 3 THEN DO:
      ON ROW-DISPLAY OF dynbrwh PERSISTENT RUN VALUE(procname) IN SOURCE-PROCEDURE.
   END.   
   ELSE IF val = 4 THEN DO:
      ON OFF-END OF dynbrwh PERSISTENT RUN VALUE(procname) IN SOURCE-PROCEDURE.
   END.   
   ELSE IF val = 5 THEN DO:
      ON OFF-HOME OF dynbrwh PERSISTENT RUN VALUE(procname) IN SOURCE-PROCEDURE.
   END.   
   ELSE IF val = 6 THEN DO:
      ON END OF dynbrwh PERSISTENT RUN VALUE(procname) IN SOURCE-PROCEDURE.
   END.   
   ELSE IF val = 7 THEN DO:
      ON HOME OF dynbrwh PERSISTENT RUN VALUE(procname) IN SOURCE-PROCEDURE.
   END.   
END PROCEDURE.

/*------------------------------------------------------------------------------
   Namn:       setcolindex_UI                
   Syfte:      -  
   In-data:    -
   Ut-data:    -
   Kommentar:  -
------------------------------------------------------------------------------*/
PROCEDURE setcolindex_UI :
   DEFINE INPUT PARAMETER indname AS CHARACTER NO-UNDO.
   IF indname = "" THEN indname = ?.
   colindex = indname.
END PROCEDURE.


/*------------------------------------------------------------------------------
   Namn:       openbdynspec_UI                
   Syfte:      -  
   In-data:    -
   Ut-data:    -
   Kommentar:  -
------------------------------------------------------------------------------*/
PROCEDURE openbdynspec_UI :
   RUN openbdyn_UI (INPUT colsortcharinput).
END PROCEDURE.

/*------------------------------------------------------------------------------
   Namn:       fetchselrowid_UI                
   Syfte:      -  
   In-data:    -
   Ut-data:    -
   Kommentar:  -
------------------------------------------------------------------------------*/
PROCEDURE fetchselrowid_UI :
   IF dynbrwh:NUM-SELECTED-ROWS = 0 THEN DO:
      lastbrwrow = ?.
   END.
   ELSE DO: 
      dynbrwh:FETCH-SELECTED-ROW(1).
      dynbuffh = dynqueh:GET-BUFFER-HANDLE.
      lastbrwrow = dynbuffh:ROWID.
   END.
END PROCEDURE.
PROCEDURE setdefaultcol_UI :
   DEFINE INPUT PARAMETER incol AS INTEGER.
   IF incol <= dynbrwh:NUM-COLUMNS AND incol > 0 THEN defaultcol = incol.   
   ELSE MESSAGE "setdefaultcol_UI - Ange ett värde mellan 1 och " dynbrwh:NUM-COLUMNS
      VIEW-AS ALERT-BOX TITLE "Elpool Error".
END PROCEDURE.


/*------------------------------------------------------------------------------
   Namn:       title_UI                
   Syfte:      -  
   In-data:    -
   Ut-data:    -
   Kommentar:  -
------------------------------------------------------------------------------*/
PROCEDURE title_UI :
   DEFINE VARIABLE antanurval AS INTEGER NO-UNDO.
   RUN getnumresult_UI (OUTPUT antanurval).
   dynbrwh:TITLE = orgtitle + " Antal " + STRING(antanurval).
   dynbrwh:MAX-DATA-GUESS = antanurval.
   dynqueh:GET-FIRST(NO-LOCK).
END PROCEDURE.

/*------------------------------------------------------------------------------
   Namn:       maxdata_UI                
   Syfte:      -  
   In-data:    -
   Ut-data:    -
   Kommentar:  -
------------------------------------------------------------------------------*/
PROCEDURE maxdata_UI :
   DEFINE VARIABLE antanurval AS INTEGER NO-UNDO.
   RUN getnumresult_UI (OUTPUT antanurval).
   dynbrwh:MAX-DATA-GUESS = antanurval.
   dynqueh:GET-FIRST(NO-LOCK).
END PROCEDURE.

/*------------------------------------------------------------------------------
   Namn:       setorgtitle_UI                
   Syfte:      -  
   In-data:    -
   Ut-data:    -
   Kommentar:  -
------------------------------------------------------------------------------*/
PROCEDURE setorgtitle_UI :
   DEFINE INPUT PARAMETER titlevar AS CHARACTER NO-UNDO.
   orgtitle = titlevar.   
END PROCEDURE.


/*------------------------------------------------------------------------------
   Namn:       title_UI                
   Syfte:      -  
   In-data:    -
   Ut-data:    -
   Kommentar:  -
------------------------------------------------------------------------------*/
PROCEDURE settitlenum_UI :
   DEFINE INPUT PARAMETER templog AS LOGICAL NO-UNDO.
   titlelog = templog.
END PROCEDURE.

/*------------------------------------------------------------------------------
   Namn:       setmultvar_UI                
   Syfte:      -  
   In-data:    -
   Ut-data:    -
   Kommentar:  -
------------------------------------------------------------------------------*/
PROCEDURE setmultvar_UI :
   DEFINE INPUT PARAMETER multi AS LOGICAL NO-UNDO.
   multvar = multi.
END PROCEDURE.

/*------------------------------------------------------------------------------
   Namn:       ejtmultibr_UI                
   Syfte:      -  
   In-data:    -
   Ut-data:    -
   Kommentar:  -
------------------------------------------------------------------------------*/
PROCEDURE ejtmultibr_UI :
   DEFINE INPUT PARAMETER brwrow AS ROWID NO-UNDO.
   lastbrwrow = brwrow.
   dynbrwh:DESELECT-ROWS().      
   RUN lastselectdyn_UI. 
END PROCEDURE.

/*------------------------------------------------------------------------------
   Namn:       sethidden_UI
   Syfte:      Möjlighet att sätta browserns HIDDEN attribut  
   In-data:    TRUE - Gömmer browsern
               FALSE - Visar browsern
   Ut-data:    -
   Kommentar:  -
------------------------------------------------------------------------------*/
PROCEDURE sethidden_UI :
   DEFINE INPUT PARAMETER hiddlog AS LOGICAL NO-UNDO.
   dynbrwh:HIDDEN = hiddlog.
END PROCEDURE.

/*------------------------------------------------------------------------------
   Namn:       selfocusrow_UI
   Syfte:      Möjlighet att marker den rad som har fokus  
   In-data:    -
   Ut-data:    -
   Kommentar:  -
------------------------------------------------------------------------------*/
PROCEDURE selfocusrow_UI :
   dynbrwh:SELECT-FOCUSED-ROW() NO-ERROR.
END PROCEDURE.

/*------------------------------------------------------------------------------
   Namn:       getnumresult_UI                
   Syfte:      -  
   In-data:    -
   Ut-data:    -
   Kommentar:  -
------------------------------------------------------------------------------*/
PROCEDURE getnumresult_UI :
   DEFINE OUTPUT PARAMETER numresult AS INTEGER NO-UNDO.
   dynqueh:GET-LAST(NO-LOCK).
   numresult = dynqueh:NUM-RESULTS.
END PROCEDURE.

/*------------------------------------------------------------------------------
   Namn:       getcolname_UI
   Syfte:      -  
   In-data:    -
   Ut-data:    -
   Kommentar:  -
------------------------------------------------------------------------------*/
PROCEDURE getcolname_UI :
   DEFINE OUTPUT PARAMETER colnamevar AS CHARACTER NO-UNDO.
   DEFINE OUTPUT PARAMETER ascdesclog AS LOGICAL NO-UNDO. /* FALSE = Ascending, TRUE = Descending */
   IF VALID-HANDLE(dyncurcolh) THEN DO:
      ASSIGN
      colnamevar = dyncurcolh:NAME
      ascdesclog = descvarcol.
   END.
END PROCEDURE.    


/*------------------------------------------------------------------------------
   Namn:       selnextprevrow_UI                
   Syfte:      -  
   In-data:    -
   Ut-data:    -
   Kommentar:  -
------------------------------------------------------------------------------*/
PROCEDURE selnextprevrow_UI :
/*    MESSAGE STRING(dynbuffh:ROWID) dynqueh:CURRENT-RESULT-ROW. */
   dynqueh:GET-NEXT(NO-LOCK). 
   IF dynqueh:QUERY-OFF-END THEN DO:
      dynqueh:GET-PREV(NO-LOCK). 
      dynqueh:GET-PREV(NO-LOCK).
      IF dynqueh:QUERY-OFF-END THEN lastbrwrow = ?.
      ELSE lastbrwrow = dynbuffh:ROWID.       
      dynqueh:GET-NEXT(NO-LOCK).
   END.
   ELSE DO: 
      lastbrwrow = dynbuffh:ROWID.
      dynqueh:GET-PREV(NO-LOCK). 
   END.   
END PROCEDURE.


/*------------------------------------------------------------------------------
   Namn:       setdescvarcol_UI
   Syfte:      -  
   In-data:    -
   Ut-data:    -
   Kommentar:  -
------------------------------------------------------------------------------*/
PROCEDURE setdescvarcol_UI :
   DEFINE INPUT PARAMETER ascdesclog AS LOGICAL NO-UNDO. /* FALSE = Ascending, TRUE = Descending */
   IF VALID-HANDLE(dyncurcolh) THEN DO:
       descvarcol = ascdesclog.
   END.
END PROCEDURE.    



/*------------------------------------------------------------------------------
   Namn:       refreshbrw_UI                
   Syfte:      -  
   In-data:    -
   Ut-data:    -
   Kommentar:  -
------------------------------------------------------------------------------*/
PROCEDURE refreshbrw_UI :
   IF dynqueh:PREPARE-STRING = ? THEN DO:
      RUN openbdyn_UI (INPUT "").
   END.
   ELSE DO:
      kommandosortquery = dynqueh:PREPARE-STRING.
      dynqueh:QUERY-PREPARE(kommandosortquery).
      dynqueh:QUERY-OPEN().
      
      dynbuffh = dynqueh:GET-BUFFER-HANDLE.
   END.
END PROCEDURE.

/*------------------------------------------------------------------------------
   Namn:       brwsetupstop_UI                
   Syfte:      -  
   In-data:    -
   Ut-data:    -
   Kommentar:  -
------------------------------------------------------------------------------*/
PROCEDURE brwsetupstop_UI :
   DEFINE INPUT PARAMETER vad AS INTEGER NO-UNDO.
   IF vad = 1 THEN dynbrwh:ALLOW-COLUMN-SEARCHING = FALSE.
   IF vad = 2 THEN dynbrwh:COLUMN-RESIZABLE       = FALSE.
   IF vad = 3 THEN DO:
      ASSIGN
      dynbrwh:ALLOW-COLUMN-SEARCHING = FALSE
      dynbrwh:COLUMN-RESIZABLE       = FALSE. 
   END.
END PROCEDURE.

/*------------------------------------------------------------------------------
   Namn:       brwsetup_UI                
   Syfte:      -  
   In-data:    -
   Ut-data:    -
   Kommentar:  -
------------------------------------------------------------------------------*/
PROCEDURE brwsetup_UI :
   ASSIGN
   dynbrwh:ALLOW-COLUMN-SEARCHING = TRUE
   dynbrwh:COLUMN-RESIZABLE       = TRUE
   dyncurcolh = dynbrwh:FIRST-COLUMN.
   
   COLOR-TABLE:NUM-ENTRIES = 50.
   colvalnumber = 20.
   disbrwcol = 21.
   COLOR-TABLE:SET-DYNAMIC(colvalnumber, YES).
   COLOR-TABLE:SET-RGB-VALUE(colvalnumber, RGB-VALUE(242,240,238)).
   COLOR-TABLE:SET-DYNAMIC(disbrwcol, YES).
   COLOR-TABLE:SET-RGB-VALUE(disbrwcol, RGB-VALUE(212,208,200)).   
END PROCEDURE.



/******************************** Tillägg 2004-03-19 ********************************/

/*------------------------------------------------------------------------------
   Namn:       multiselect_UI                
   Syfte:      Att markera de poster som finns i multiseltemp tabellen.
   In-data:    -
   Ut-data:    -
   Kommentar:  -
------------------------------------------------------------------------------*/
PROCEDURE multiselect_UI :
   dynbrwh:REFRESHABLE = FALSE.  /* Ingen uppdatering av browser */
   FOR EACH multiseltemp BY NUMSEL DESCENDING:
      dynok = dynqueh:REPOSITION-TO-ROWID(multiseltemp.SELROW) NO-ERROR.  /* Positionerar queryn */
      IF dynok = TRUE THEN dynbrwh:SELECT-FOCUSED-ROW() NO-ERROR.    /* Markerar postitionerad post */
   END.
   dynbrwh:REFRESHABLE = TRUE.   /* Först nu uppdateras förändringarna */
   RUN fetchselrowid_UI.
   RUN lastselectdyn_UI.
END PROCEDURE.


/*------------------------------------------------------------------------------
   Namn:       selmulti_UI                
   Syfte:      Skapa en ny post för varje markerad rad i en browser.
   In-data:    -
   Ut-data:    -
   Kommentar:  -
------------------------------------------------------------------------------*/
PROCEDURE selmulti_UI :
   EMPTY TEMP-TABLE multiseltemp NO-ERROR.   /* Tömmer temp-tabell */
   tempcounter = 1.
   DO WHILE tempcounter LE dynbrwh:NUM-SELECTED-ROWS: /* För varje markerad rad */
      dynbrwh:FETCH-SELECTED-ROW(tempcounter).  /* 'Fånga' raden utifrån ett nummer */
      CREATE multiseltemp.
      ASSIGN
      multiseltemp.NUMSEL = tempcounter   /* Sparar undan markeringsordningen */
      multiseltemp.SELROW = dynbuffh:ROWID.  /* Sparar Rowid för posten */
      tempcounter = tempcounter + 1.
   END.
END PROCEDURE.


